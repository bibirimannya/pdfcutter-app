import os
import uuid
import time
import threading
import atexit
import tempfile
import shutil
from contextlib import contextmanager
from flask import Flask, render_template, request, redirect, url_for, flash, send_file, jsonify, abort, after_this_request
from werkzeug.utils import secure_filename
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
import PyPDF2
from config import Config

app = Flask(__name__)
app.config.from_object(Config)

# レート制限の設定
limiter = Limiter(
    key_func=get_remote_address,
    app=app,
    default_limits=["200 per day", "50 per hour"]
)

ALLOWED_EXTENSIONS = {'pdf'}

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def ensure_directories():
    """必要なディレクトリが存在することを確認"""
    os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
    os.makedirs(app.config['DOWNLOAD_FOLDER'], exist_ok=True)

@contextmanager
def temporary_file(suffix='.pdf', dir=None):
    """一時ファイルの安全な管理"""
    temp_file = None
    try:
        fd, temp_file = tempfile.mkstemp(suffix=suffix, dir=dir)
        os.close(fd)  # ファイルディスクリプタを閉じる
        yield temp_file
    finally:
        if temp_file and os.path.exists(temp_file):
            try:
                os.remove(temp_file)
            except Exception as e:
                app.logger.error(f"Failed to remove temp file {temp_file}: {e}")

def validate_pdf_content(file_path):
    """PDFファイルの内容を検証"""
    try:
        with open(file_path, 'rb') as f:
            header = f.read(4)
            if header != b'%PDF':
                return False
            f.seek(0)
            pdf_reader = PyPDF2.PdfReader(f)
            
            if len(pdf_reader.pages) > app.config['MAX_PAGES_PER_PDF']:
                return False
                
            for i, page in enumerate(pdf_reader.pages):
                if i > 2:
                    break
                try:
                    _ = page.extract_text()
                except:
                    return False
            return True
    except Exception as e:
        app.logger.error(f"PDF validation error: {e}")
        return False

def cleanup_old_files():
    """古いファイルを定期的に削除"""
    while True:
        try:
            current_time = time.time()
            for folder in [app.config['UPLOAD_FOLDER'], app.config['DOWNLOAD_FOLDER']]:
                if not os.path.exists(folder):
                    continue
                for filename in os.listdir(folder):
                    file_path = os.path.join(folder, filename)
                    if os.path.isfile(file_path):
                        # 30分以上古いファイルを削除（より短い間隔に変更）
                        if current_time - os.path.getctime(file_path) > 1800:
                            try:
                                os.remove(file_path)
                                app.logger.info(f"Cleaned up old file: {filename}")
                            except Exception as e:
                                app.logger.error(f"Failed to remove {filename}: {e}")
            time.sleep(300)  # 5分おきにチェック
        except Exception as e:
            app.logger.error(f"Cleanup thread error: {e}")
            time.sleep(300)

def schedule_file_deletion(file_path, delay=60):
    """指定した時間後にファイルを削除"""
    def delete_after_delay():
        time.sleep(delay)
        if os.path.exists(file_path):
            try:
                os.remove(file_path)
                app.logger.info(f"Scheduled deletion completed: {file_path}")
            except Exception as e:
                app.logger.error(f"Failed scheduled deletion: {e}")
    
    thread = threading.Thread(target=delete_after_delay, daemon=True)
    thread.start()

@app.before_request
def limit_file_size():
    if request.content_length and request.content_length > app.config['MAX_CONTENT_LENGTH']:
        abort(413)

@app.after_request
def after_request(response):
    response.headers['X-Content-Type-Options'] = 'nosniff'
    response.headers['X-Frame-Options'] = 'DENY'
    response.headers['X-XSS-Protection'] = '1; mode=block'
    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'
    response.headers['Content-Security-Policy'] = "default-src 'self'"
    return response

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/privacy')
def privacy():
    return render_template('privacy.html')

@app.route('/terms')
def terms():
    return render_template('terms.html')
@app.route('/split', methods=['POST'])
@limiter.limit("5 per minute")
def split_pdf():
    if 'file' not in request.files:
        return jsonify({'error': 'ファイルが選択されていません'}), 400
    
    file = request.files['file']
    if file.filename == '' or not allowed_file(file.filename):
        return jsonify({'error': '有効なPDFファイルを選択してください'}), 400
    
    try:
        filename = secure_filename(file.filename)
        if not filename:
            return jsonify({'error': '無効なファイル名です'}), 400
        
        # 一時ファイルを使用してアップロードファイルを処理
        with temporary_file(suffix='.pdf', dir=app.config['UPLOAD_FOLDER']) as temp_path:
            file.save(temp_path)
            
            if not validate_pdf_content(temp_path):
                return jsonify({'error': '無効または破損したPDFファイルです'}), 400
            
            with open(temp_path, 'rb') as pdf_file:
                pdf_reader = PyPDF2.PdfReader(pdf_file)
                total_pages = len(pdf_reader.pages)
                
                if total_pages > app.config['MAX_PAGES_PER_PDF']:
                    return jsonify({'error': f'ページ数が上限（{app.config["MAX_PAGES_PER_PDF"]}ページ）を超えています'}), 400
                
                split_files = []
                
                for page_num in range(total_pages):
                    pdf_writer = PyPDF2.PdfWriter()
                    pdf_writer.add_page(pdf_reader.pages[page_num])
                    
                    output_filename = f"page_{page_num + 1}_{uuid.uuid4().hex}.pdf"
                    output_path = os.path.join(app.config['DOWNLOAD_FOLDER'], output_filename)
                    
                    with open(output_path, 'wb') as output_file:
                        pdf_writer.write(output_file)
                    
                    # ファイルの自動削除をスケジュール（10分後）
                    schedule_file_deletion(output_path, delay=600)
                    
                    split_files.append({
                        'filename': output_filename,
                        'page': page_num + 1,
                        'download_url': url_for('download_file', filename=output_filename)
                    })
        
        return jsonify({
            'success': True,
            'message': f'PDFを{total_pages}ページに分割しました',
            'files': split_files
        })
        
    except Exception as e:
        app.logger.error(f"Split PDF error: {e}")
        return jsonify({'error': '処理中にエラーが発生しました'}), 500

@app.route('/merge', methods=['POST'])
@limiter.limit("3 per minute")
def merge_pdf():
    if 'files[]' not in request.files:
        return jsonify({'error': 'ファイルが選択されていません'}), 400
    
    files = request.files.getlist('files[]')
    if len(files) < 2:
        return jsonify({'error': '結合には2つ以上のPDFファイルが必要です'}), 400
    
    if len(files) > app.config['MAX_FILES_PER_REQUEST']:
        return jsonify({'error': f'一度にアップロード可能なファイル数は{app.config["MAX_FILES_PER_REQUEST"]}個までです'}), 400
    
    try:
        pdf_writer = PyPDF2.PdfWriter()
        total_pages = 0
        temp_files = []
        
        # 一時ディレクトリを作成
        with tempfile.TemporaryDirectory(dir=app.config['UPLOAD_FOLDER']) as temp_dir:
            for file in files:
                if file.filename == '' or not allowed_file(file.filename):
                    continue
                    
                filename = secure_filename(file.filename)
                if not filename:
                    continue
                
                temp_path = os.path.join(temp_dir, f"temp_{uuid.uuid4().hex}_{filename}")
                file.save(temp_path)
                temp_files.append(temp_path)
                
                if not validate_pdf_content(temp_path):
                    return jsonify({'error': f'{filename}は無効または破損したPDFファイルです'}), 400
                
                with open(temp_path, 'rb') as pdf_file:
                    pdf_reader = PyPDF2.PdfReader(pdf_file)
                    page_count = len(pdf_reader.pages)
                    total_pages += page_count
                    
                    if total_pages > app.config['MAX_PAGES_PER_PDF']:
                        return jsonify({'error': f'結合後の総ページ数が上限（{app.config["MAX_PAGES_PER_PDF"]}ページ）を超えています'}), 400
                    
                    for page in pdf_reader.pages:
                        pdf_writer.add_page(page)
            
            if total_pages == 0:
                return jsonify({'error': '有効なPDFファイルがありませんでした'}), 400
            
            # 結合されたPDFを保存
            merged_filename = f"merged_{uuid.uuid4().hex}.pdf"
            merged_path = os.path.join(app.config['DOWNLOAD_FOLDER'], merged_filename)
            
            with open(merged_path, 'wb') as output_file:
                pdf_writer.write(output_file)
            
            # ファイルの自動削除をスケジュール（10分後）
            schedule_file_deletion(merged_path, delay=600)
        
        return jsonify({
            'success': True,
            'message': f'{len(temp_files)}個のPDFファイルを結合しました',
            'filename': merged_filename,
            'download_url': url_for('download_file', filename=merged_filename)
        })
        
    except Exception as e:
        app.logger.error(f"Merge PDF error: {e}")
        return jsonify({'error': '処理中にエラーが発生しました'}), 500

@app.route('/download/<filename>')
def download_file(filename):
    try:
        filename = secure_filename(filename)
        if not filename or '.' not in filename or not filename.endswith('.pdf'):
            abort(404)
        
        file_path = os.path.join(app.config['DOWNLOAD_FOLDER'], filename)
        file_path = os.path.abspath(file_path)
        download_dir = os.path.abspath(app.config['DOWNLOAD_FOLDER'])
        
        if not file_path.startswith(download_dir):
            abort(403)
        
        if not os.path.exists(file_path):
            abort(404)
        
        # ダウンロード完了後にファイルを削除
        @after_this_request
        def remove_file(response):
            try:
                # 少し遅延を入れてから削除（ダウンロード完了を確実にするため）
                schedule_file_deletion(file_path, delay=30)
            except Exception as e:
                app.logger.error(f"Error scheduling file deletion: {e}")
            return response
        
        return send_file(file_path, as_attachment=True)
        
    except FileNotFoundError:
        abort(404)
    except Exception as e:
        app.logger.error(f"Download error: {e}")
        abort(500)

@app.errorhandler(413)
def too_large(e):
    return jsonify({'error': 'ファイルサイズが大きすぎます'}), 413

@app.route('/privacy')
def privacy():
    return render_template('privacy.html')

@app.route('/terms')
def terms():
    return render_template('terms.html')
if __name__ == '__main__':
    ensure_directories()
    
    # クリーンアップスレッドを開始
    cleanup_thread = threading.Thread(target=cleanup_old_files, daemon=True)
    cleanup_thread.start()
    
    app.run(debug=False, host='127.0.0.1', port=5000)
